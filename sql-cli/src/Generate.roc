interface Generate
    exposes [module]
    imports [Name, Schema.{ Schema }]

module : Schema -> Str
module = \schema ->
    moduleName = Name.module (Schema.getName schema)
    tables = Schema.getTables schema

    tableDefs : List { name : Str, def : Str }
    tableDefs =
        List.map tables \table -> tableDef table schema

    rocExposes : Str
    rocExposes =
        tableDefs
        |> List.map \{ name } -> indent "\(name)," 2
        |> Str.joinWith "\n"

    rocDefs : Str
    rocDefs =
        tableDefs
        |> List.map .def
        |> Str.joinWith "\n\n"

    """
    # This file was automatically generated by roc-sql
    interface \(moduleName) 
        exposes [
    \(rocExposes)
        ]
        imports [
            pg.Sql.{ identifier },
            pg.Sql.Types,
        ]

    \(rocDefs)
    """

tableDef : Schema.Table, Schema -> { name : Str, def : Str }
tableDef = \table, schema ->
    defName : Str
    defName = Name.identifier table.name

    columnDefs : List { field : Str, primaryDef : Result Str [None] }
    columnDefs =
        List.map table.columns \column -> columnDef column table.id schema

    primaryColumns : Str
    primaryColumns =
        columnDefs
        |> List.keepOks .primaryDef
        |> Str.joinWith "\n\n"

    columnsFields : Str
    columnsFields =
        columnDefs
        |> List.map .field
        |> Str.joinWith "\n"

    def : Str
    def =
        """
        \(primaryColumns)

        \(defName) = {
            schema: \(Name.sqlName (Schema.getName schema)),
            name: \(Name.sqlName table.name),
            alias: "\(Name.tableAlias table.name)",
            columns: \\alias -> {
        \(columnsFields)
            },
        }
        """

    { name: defName, def }

columnDef : Schema.Column, I32, Schema -> { field : Str, primaryDef : Result Str [None] }
columnDef = \column, tableId, schema ->
    fieldName = Name.identifier column.name

    columnId = (tableId, column.num)

    { primaryDef, type } =
        when Schema.primaryColumn schema columnId is
            Ok pcol ->
                qualifiedName = "\(pcol.tableName)_\(pcol.columnName)"
                defName = Name.identifier qualifiedName

                pdef =
                    if pcol.id == columnId then
                        (expr, pg, roc) = columnType column

                        pgWithKey =
                            # TODO: make this more elegant
                            Str.replaceFirst pg "*" "{ \(defName): {} }"

                        """
                        \(defName) : Sql.Types.Decode \(pgWithKey) \(roc)
                        \(defName) = \(expr)
                        """
                        |> Ok
                    else
                        Err None

                { primaryDef: pdef, type: defName }

            Err KeyNotFound ->
                { primaryDef: Err None, type: (columnType column).0 }

    decoderExpr =
        if column.isNullable then
            asNullable type
        else
            type

    columnName = Name.sqlName column.name

    field =
        "\(fieldName): identifier alias \(columnName) \(decoderExpr),"
        |> indent 2

    { field, primaryDef }

columnType : Schema.Column -> (Str, Str, Str)
columnType = \column ->
    when (column.typeCategory, column.elemDataType) is
        ("A", NotNull elemType) ->
            (expr, pg, roc) = pgType elemType

            (
                "(Sql.Types.array \(asNullable expr))",
                "(Sql.Types.PgArray (\(pg)) *)",
                "(List \(roc))",
            )

        _ ->
            pgType column.dataType

pgType : Str -> (Str, Str, Str)
pgType = \sqlType ->
    when unqualifiedPgType sqlType is
        Ok (expr, pg, roc) ->
            ("Sql.Types.\(expr)", "(Sql.Types.\(pg) *)", roc)

        Err Unsupported ->
            ("(Sql.Types.unsupported \"\(sqlType)\")", "*", "Sql.Types.Raw")

unqualifiedPgType : Str -> Result (Str, Str, Str) [Unsupported]
unqualifiedPgType = \sqlType ->
    when sqlType is
        "int2" ->
            Ok ("i16", "PgI16", "I16")

        "int4" | "oid" | "xid" ->
            Ok ("i32", "PgI32", "I32")

        "int8" ->
            Ok ("i64", "PgI64", "I64")

        "float4" ->
            Ok ("f32", "PgF32", "F32")

        "float8" ->
            Ok ("f64", "PgF64", "F64")

        "numeric" ->
            Ok ("dec", "PgDec", "Dec")

        "text" | "char" | "name" | "bpchar" | "varchar" ->
            Ok ("str", "PgText", "Str")

        "bool" ->
            Ok ("bool", "PgBool", "Bool")

        "uuid" ->
            Ok ("uuid", "PgUuid", "Str")

        _ ->
            # TODO:
            # https://www.postgresql.org/docs/current/datatype.html
            # - bytea
            # - date/time
            # - enums
            # - geo
            # - net
            # - bit strings
            # - text search
            # - json
            # - composite
            Err Unsupported

asNullable : Str -> Str
asNullable = \inner -> "(Sql.Types.nullable \(inner))"

indent : Str, Nat -> Str
indent = \line, count ->
    spaces = Str.repeat "    " count
    "\(spaces)\(line)"
