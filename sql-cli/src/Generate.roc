module [module]

import Name
import Schema exposing [Schema]

module : Schema -> Str
module = |schema|
    module_name = Name.module(Schema.get_name(schema))
    tables = Schema.get_tables(schema)

    table_defs : List { name : Str, def : Str }
    table_defs =
        List.map(tables, |table| table_def(table, schema))

    roc_exposes : Str
    roc_exposes =
        table_defs
        |> List.map(|{ name }| indent("${name},", 2))
        |> Str.join_with("\n")

    roc_defs : Str
    roc_defs =
        table_defs
        |> List.map(.def)
        |> Str.join_with("\n\n")

    """
    # This file was automatically generated by roc-sql
    interface ${module_name} 
        exposes [
    ${roc_exposes}
        ]
        imports [
            pg.Sql.{ identifier },
            pg.Sql.Types,
        ]

    ${roc_defs}
    """

table_def : Schema.Table, Schema -> { name : Str, def : Str }
table_def = |table, schema|
    def_name : Str
    def_name = Name.identifier(table.name)

    column_defs : List { field : Str, primary_def : Result Str [None] }
    column_defs =
        List.map(table.columns, |column| column_def(column, table.id, schema))

    primary_columns : Str
    primary_columns =
        column_defs
        |> List.keep_oks(.primary_def)
        |> Str.join_with("\n\n")

    columns_fields : Str
    columns_fields =
        column_defs
        |> List.map(.field)
        |> Str.join_with("\n")

    def : Str
    def =
        """
        ${primary_columns}

        ${def_name} = {
            schema: ${Name.sql_name(Schema.get_name(schema))},
            name: ${Name.sql_name(table.name)},
            alias: "${Name.table_alias(table.name)}",
            columns: \\alias -> {
        ${columns_fields}
            },
        }
        """

    { name: def_name, def }

column_def : Schema.Column, I32, Schema -> { field : Str, primary_def : Result Str [None] }
column_def = |column, table_id, schema|
    field_name = Name.identifier(column.name)

    column_id = (table_id, column.num)

    { primary_def, type } =
        when Schema.primary_column(schema, column_id) is
            Ok(pcol) ->
                qualified_name = "${pcol.table_name}_${pcol.column_name}"
                def_name = Name.identifier(qualified_name)

                pdef =
                    if pcol.id == column_id then
                        (expr, pg, roc) = column_type(column)

                        pg_with_key =
                            # TODO: make this more elegant
                            Str.replace_first(pg, "*", "{ ${def_name}: {} }")

                        """
                        ${def_name} : Sql.Types.Decode ${pg_with_key} ${roc}
                        ${def_name} = ${expr}
                        """
                        |> Ok
                    else
                        Err(None)

                { primary_def: pdef, type: def_name }

            Err(KeyNotFound) ->
                { primary_def: Err(None), type: (column_type(column)).0 }

    decoder_expr =
        if column.is_nullable then
            as_nullable(type)
        else
            type

    column_name = Name.sql_name(column.name)

    field =
        "${field_name}: identifier alias ${column_name} ${decoder_expr},"
        |> indent(2)

    { field, primary_def }

column_type : Schema.Column -> (Str, Str, Str)
column_type = |column|
    when (column.type_category, column.elem_data_type) is
        ("A", NotNull(elem_type)) ->
            (expr, pg, roc) = pg_type(elem_type)

            (
                "(Sql.Types.array ${as_nullable(expr)})",
                "(Sql.Types.PgArray (${pg}) *)",
                "(List ${roc})",
            )

        _ ->
            pg_type(column.data_type)

pg_type : Str -> (Str, Str, Str)
pg_type = |sql_type|
    when unqualified_pg_type(sql_type) is
        Ok((expr, pg, roc)) ->
            ("Sql.Types.${expr}", "(Sql.Types.${pg} *)", roc)

        Err(Unsupported) ->
            ("(Sql.Types.unsupported \"${sql_type}\")", "*", "Sql.Types.Raw")

unqualified_pg_type : Str -> Result (Str, Str, Str) [Unsupported]
unqualified_pg_type = |sql_type|
    when sql_type is
        "int2" ->
            Ok(("i16", "PgI16", "I16"))

        "int4" | "oid" | "xid" ->
            Ok(("i32", "PgI32", "I32"))

        "int8" ->
            Ok(("i64", "PgI64", "I64"))

        "float4" ->
            Ok(("f32", "PgF32", "F32"))

        "float8" ->
            Ok(("f64", "PgF64", "F64"))

        "numeric" ->
            Ok(("dec", "PgDec", "Dec"))

        "text" | "char" | "name" | "bpchar" | "varchar" ->
            Ok(("str", "PgText", "Str"))

        "bool" ->
            Ok(("bool", "PgBool", "Bool"))

        "uuid" ->
            Ok(("uuid", "PgUuid", "Str"))

        _ ->
            # TODO:
            # https://www.postgresql.org/docs/current/datatype.html
            # - bytea
            # - date/time
            # - enums
            # - geo
            # - net
            # - bit strings
            # - text search
            # - json
            # - composite
            Err(Unsupported)

as_nullable : Str -> Str
as_nullable = |inner| "(Sql.Types.nullable ${inner})"

indent : Str, U64 -> Str
indent = |line, count|
    spaces = Str.repeat("    ", count)
    "${spaces}${line}"
